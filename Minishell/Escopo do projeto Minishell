											26/02/2025
***************************************Escopo do projeto Minishell*************************************

/minishell
├── Makefile              // Regras para compilar o projeto, incluindo all, clean, fclean, re e bonus (se houver)
├── minishell.h           // Cabeçalho principal com includes, defines e declarações de estruturas e funções globais
├── main.c                // Função principal: inicializa, entra no loop de leitura (prompt), chama parser e executor
├── parser
│   ├── parser.c          // Funções de tokenização, tratamento de aspas, redirecionamentos e construção da estrutura de comandos
│   ├── parser.h          // Protótipos e estruturas relacionadas ao parser
│   └── parser_bonus.c    // Funções extras para tratar operadores lógicos (&&, ||) e agrupamento com parênteses (bonus)
├── executor
│   ├── executor.c        // Execução dos comandos, criação de processos, gerenciamento de pipes e redirecionamentos
│   ├── executor.h        // Protótipos e estruturas para execução
│   └── executor_bonus.c  // Tratamento de condições extras e expansão de wildcards (bonus)
├── builtins
│   ├── builtins.c        // Implementação dos builtins: echo, cd, pwd, export, unset, env e exit
│   └── builtins.h        // Protótipos e definições dos builtins
├── utils
│   ├── utils.c           // Funções auxiliares: manipulação de strings, tratamento de erros, gerenciamento de memória, etc.
│   ├── utils.h           // Protótipos das funções utilitárias
│   └── wildcard.c        // Função(s) específica(s) para expansão de wildcards (*) (bonus)
└── libft                 // Pasta contendo a sua própria libft
    ├── Makefile          // Makefile da libft
    ├── *.c               // Código fonte da libft
    └── *.h               // Headers da libft

________________________________________________________________________________________________________

                                                                        🧭️💻️Historico de ações na criação do projeto Minishell🧭️💻️                                                                  26/02/2025
 ⚠️main.c⚠️
🚩️OBS: Deixaremos o Makefile e os arquivos.h "por ultimo".🚩️
Vamos começar criando o arquivo main.c. Nele, teremos a função principal que inicializa o ambiente do shell, configura os signal handlers (deixarei um comentário indicando onde implementar) e entra num loop principal para ler os comandos, chamar o parser e o executor e, por fim, liberar os recursos.
	👨‍🏫️Explicação do Código👨‍🏫️
1️⃣️Inicialização do Shell:
A função init_shell (a ser implementada) deve copiar o ambiente (envp) e preparar as variáveis necessárias para o funcionamento do shell.

2️⃣️Signal Handlers:
A função setup_signals é chamada para configurar o tratamento dos sinais (como ctrl-C, ctrl-D e ctrl-\), evitando que o shell saia de forma inesperada.

3️⃣️Loop Principal:
Dentro do loop, usamos readline para exibir o prompt e ler o comando do usuário. Se a linha não estiver vazia, ela é adicionada ao histórico com add_history. Em seguida, o comando é passado para o parser (parse_input), que deve montar a estrutura dos comandos, e, se não houver erro, o executor (execute_commands) é chamado.

4️⃣️Liberação de Recursos:
Ao final de cada iteração, a linha lida e as estruturas temporárias são liberadas para evitar vazamentos de memória. Ao sair do loop (quando o usuário envia um EOF com ctrl-D), o shell é finalizado com free_shell.

Com esse arquivo main.c temos o ponto de entrada do nosso Minishell. Nos próximos passos, iremos criar os arquivos dos módulos (parser, executor, builtins, utils) e, por fim, os headers e o Makefile


                                                                                                   ‼️‼️PARSER‼️‼️  🏳️🚩️ OBS:É no Parser que sera implementado o Bônus.🚩️🏳️            

⚠️parser.c⚠️                                                                                                
	👨‍🏫️Explicação do Código👨‍🏫️
1️⃣️tokenize_line:
Essa função (a ser implementada) deve dividir a linha em tokens, considerando espaços, aspas, redirecionamentos e pipes.

2️⃣️build_commands:
Após tokenizar, essa função monta a estrutura de comandos na estrutura do shell (t_shell), para que o executor possa processá-la.

3️⃣️free_tokens:
Libera a memória alocada para os tokens, evitando vazamentos.

Essa implementação está simplificada e serve como ponto de partida. Cada função chamada aqui (como tokenize_line, build_commands e free_tokens)

⚠️executer.c⚠️
	👨‍🏫️Explicação do Código👨‍🏫️
1️⃣️Verificação de Comando:
Se a lista de comandos estiver vazia, retorna imediatamente com sucesso. Se o comando atual for um built-in, ele é executado diretamente sem criar um novo processo.

2️⃣️Criação de Processo:
Utilizamos fork() para criar um processo filho. Caso ocorra erro, imprimimos a mensagem de erro e retornamos ERROR.

3️⃣️Processo Filho:
No processo filho, chamamos a função setup_redirections para configurar redirecionamentos e pipes (caso implementados). Em seguida, usamos execve() para executar o comando. Se ocorrer algum erro em execve(), a mensagem de erro é exibida e o processo é finalizado.

4️⃣️Processo Pai:
O processo pai aguarda o término do filho com waitpid() e armazena o status de saída em shell->last_status.

