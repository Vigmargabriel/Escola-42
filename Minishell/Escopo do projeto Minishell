											26/02/2025
***************************************Escopo do projeto Minishell*************************************

/minishell
â”œâ”€â”€ Makefile              // Regras para compilar o projeto, incluindo all, clean, fclean, re e bonus (se houver)
â”œâ”€â”€ minishell.h           // CabeÃ§alho principal com includes, defines e declaraÃ§Ãµes de estruturas e funÃ§Ãµes globais
â”œâ”€â”€ main.c                // FunÃ§Ã£o principal: inicializa, entra no loop de leitura (prompt), chama parser e executor
â”œâ”€â”€ parser
â”‚   â”œâ”€â”€ parser.c          // FunÃ§Ãµes de tokenizaÃ§Ã£o, tratamento de aspas, redirecionamentos e construÃ§Ã£o da estrutura de comandos
â”‚   â”œâ”€â”€ parser.h          // ProtÃ³tipos e estruturas relacionadas ao parser
â”‚   â””â”€â”€ parser_bonus.c    // FunÃ§Ãµes extras para tratar operadores lÃ³gicos (&&, ||) e agrupamento com parÃªnteses (bonus)
â”œâ”€â”€ executor
â”‚   â”œâ”€â”€ executor.c        // ExecuÃ§Ã£o dos comandos, criaÃ§Ã£o de processos, gerenciamento de pipes e redirecionamentos
â”‚   â”œâ”€â”€ executor.h        // ProtÃ³tipos e estruturas para execuÃ§Ã£o
â”‚   â””â”€â”€ executor_bonus.c  // Tratamento de condiÃ§Ãµes extras e expansÃ£o de wildcards (bonus)
â”œâ”€â”€ builtins
â”‚   â”œâ”€â”€ builtins.c        // ImplementaÃ§Ã£o dos builtins: echo, cd, pwd, export, unset, env e exit
â”‚   â””â”€â”€ builtins.h        // ProtÃ³tipos e definiÃ§Ãµes dos builtins
â”œâ”€â”€ utils
â”‚   â”œâ”€â”€ utils.c           // FunÃ§Ãµes auxiliares: manipulaÃ§Ã£o de strings, tratamento de erros, gerenciamento de memÃ³ria, etc.
â”‚   â”œâ”€â”€ utils.h           // ProtÃ³tipos das funÃ§Ãµes utilitÃ¡rias
â”‚   â””â”€â”€ wildcard.c        // FunÃ§Ã£o(s) especÃ­fica(s) para expansÃ£o de wildcards (*) (bonus)
â””â”€â”€ libft                 // Pasta contendo a sua prÃ³pria libft
    â”œâ”€â”€ Makefile          // Makefile da libft
    â”œâ”€â”€ *.c               // CÃ³digo fonte da libft
    â””â”€â”€ *.h               // Headers da libft

________________________________________________________________________________________________________

                                                                        ğŸ§­ï¸ğŸ’»ï¸Historico de aÃ§Ãµes na criaÃ§Ã£o do projeto MinishellğŸ§­ï¸ğŸ’»ï¸                                                                  26/02/2025
 âš ï¸main.câš ï¸
ğŸš©ï¸OBS: Deixaremos o Makefile e os arquivos.h "por ultimo".ğŸš©ï¸
Vamos comeÃ§ar criando o arquivo main.c. Nele, teremos a funÃ§Ã£o principal que inicializa o ambiente do shell, configura os signal handlers (deixarei um comentÃ¡rio indicando onde implementar) e entra num loop principal para ler os comandos, chamar o parser e o executor e, por fim, liberar os recursos.
	ğŸ‘¨â€ğŸ«ï¸ExplicaÃ§Ã£o do CÃ³digoğŸ‘¨â€ğŸ«ï¸
1ï¸âƒ£ï¸InicializaÃ§Ã£o do Shell:
A funÃ§Ã£o init_shell (a ser implementada) deve copiar o ambiente (envp) e preparar as variÃ¡veis necessÃ¡rias para o funcionamento do shell.

2ï¸âƒ£ï¸Signal Handlers:
A funÃ§Ã£o setup_signals Ã© chamada para configurar o tratamento dos sinais (como ctrl-C, ctrl-D e ctrl-\), evitando que o shell saia de forma inesperada.

3ï¸âƒ£ï¸Loop Principal:
Dentro do loop, usamos readline para exibir o prompt e ler o comando do usuÃ¡rio. Se a linha nÃ£o estiver vazia, ela Ã© adicionada ao histÃ³rico com add_history. Em seguida, o comando Ã© passado para o parser (parse_input), que deve montar a estrutura dos comandos, e, se nÃ£o houver erro, o executor (execute_commands) Ã© chamado.

4ï¸âƒ£ï¸LiberaÃ§Ã£o de Recursos:
Ao final de cada iteraÃ§Ã£o, a linha lida e as estruturas temporÃ¡rias sÃ£o liberadas para evitar vazamentos de memÃ³ria. Ao sair do loop (quando o usuÃ¡rio envia um EOF com ctrl-D), o shell Ã© finalizado com free_shell.

Com esse arquivo main.c temos o ponto de entrada do nosso Minishell. Nos prÃ³ximos passos, iremos criar os arquivos dos mÃ³dulos (parser, executor, builtins, utils) e, por fim, os headers e o Makefile


                                                                                                   â€¼ï¸â€¼ï¸PARSERâ€¼ï¸â€¼ï¸  ğŸ³ï¸ğŸš©ï¸ OBS:Ã‰ no Parser que sera implementado o BÃ´nus.ğŸš©ï¸ğŸ³ï¸            

âš ï¸parser.câš ï¸                                                                                                
	ğŸ‘¨â€ğŸ«ï¸ExplicaÃ§Ã£o do CÃ³digoğŸ‘¨â€ğŸ«ï¸
1ï¸âƒ£ï¸tokenize_line:
Essa funÃ§Ã£o (a ser implementada) deve dividir a linha em tokens, considerando espaÃ§os, aspas, redirecionamentos e pipes.

2ï¸âƒ£ï¸build_commands:
ApÃ³s tokenizar, essa funÃ§Ã£o monta a estrutura de comandos na estrutura do shell (t_shell), para que o executor possa processÃ¡-la.

3ï¸âƒ£ï¸free_tokens:
Libera a memÃ³ria alocada para os tokens, evitando vazamentos.

Essa implementaÃ§Ã£o estÃ¡ simplificada e serve como ponto de partida. Cada funÃ§Ã£o chamada aqui (como tokenize_line, build_commands e free_tokens)

âš ï¸executer.câš ï¸
	ğŸ‘¨â€ğŸ«ï¸ExplicaÃ§Ã£o do CÃ³digoğŸ‘¨â€ğŸ«ï¸
1ï¸âƒ£ï¸VerificaÃ§Ã£o de Comando:
Se a lista de comandos estiver vazia, retorna imediatamente com sucesso. Se o comando atual for um built-in, ele Ã© executado diretamente sem criar um novo processo.

2ï¸âƒ£ï¸CriaÃ§Ã£o de Processo:
Utilizamos fork() para criar um processo filho. Caso ocorra erro, imprimimos a mensagem de erro e retornamos ERROR.

3ï¸âƒ£ï¸Processo Filho:
No processo filho, chamamos a funÃ§Ã£o setup_redirections para configurar redirecionamentos e pipes (caso implementados). Em seguida, usamos execve() para executar o comando. Se ocorrer algum erro em execve(), a mensagem de erro Ã© exibida e o processo Ã© finalizado.

4ï¸âƒ£ï¸Processo Pai:
O processo pai aguarda o tÃ©rmino do filho com waitpid() e armazena o status de saÃ­da em shell->last_status.

